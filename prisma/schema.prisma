// Prisma schema for AI Community Platform
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgvector(map: "vector")]
}

enum MemberRole {
  owner
  moderator
  member
}

enum CommunityVisibility {
  public
  private
}

enum SpaceType {
  general
  announcements
  questions
}

enum PostType {
  post
  article
}

enum PostStatus {
  draft
  published
}

enum NotificationType {
  new_comment
  mention
  new_post
  member_join
}

enum EventType {
  online
  in_person
}

enum RsvpStatus {
  going
  maybe
  not_going
}

enum SubscriptionStatus {
  active
  cancelled
  past_due
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String  @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum ApiUserRole {
  creator
  reader
}

model User {
  id            String    @id @default(cuid())
  email         String?   @unique
  emailVerified DateTime?
  name          String?
  username      String?   @unique
  image         String?
  password      String?
  role          ApiUserRole?
  bio           String?   @db.Text
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts Account[]
  sessions Session[]
  profile  Profile?

  posts       Post[]
  comments    Comment[]
  memberships Member[]
  notifications Notification[]
  createdCommunities Community[] @relation("CommunityOwner")
  eventRsvps  EventRsvp[]
  subscriptions Subscription[]
  activities  Activity[]

  creatorPosts        CreatorPost[]
  creatorPostComments CreatorPostComment[]
  creatorSubscriptionsAsSubscriber CreatorSubscription[] @relation("CreatorSubscriptionSubscriber")
  creatorSubscriptionsAsCreator   CreatorSubscription[] @relation("CreatorSubscriptionCreator")
  creatorStripeSubscriptions     CreatorStripeSubscription[]
  articles            Article[]
  articleRevisions    ArticleRevision[]
  approvedRevisions   ArticleRevision[] @relation("ArticleRevisionApprover")

  organizedPlatformEvents PlatformEvent[] @relation("PlatformEventOrganizer")
  platformEventRsvps     PlatformEventRsvp[]
}

// AI-Augmented Event Platform: standalone events (API v1)
enum PlatformEventRsvpStatus {
  attending
  interested
}

model PlatformEvent {
  id          String   @id @default(cuid())
  organizerId String
  title       String
  description String?  @db.Text
  startTime   DateTime
  endTime     DateTime
  location    String?
  ticketPrice Decimal? @db.Decimal(10, 2)
  capacity    Int?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  organizer User               @relation("PlatformEventOrganizer", fields: [organizerId], references: [id], onDelete: Cascade)
  rsvps    PlatformEventRsvp[]

  @@index([organizerId])
  @@index([startTime])
}

model PlatformEventRsvp {
  id        String                @id @default(cuid())
  userId    String
  eventId   String
  status    PlatformEventRsvpStatus @default(attending)
  createdAt DateTime              @default(now())

  user  User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  event PlatformEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@index([eventId])
  @@index([userId])
}

// Creator publishing platform: standalone posts by creators (API v1)
model CreatorPost {
  id          String   @id @default(cuid())
  creatorId   String
  title       String
  content     String   @db.Text
  status      PostStatus @default(draft)
  publishedAt DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  creator  User                 @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  comments CreatorPostComment[]

  @@index([creatorId])
  @@index([status, publishedAt])
}

model CreatorPostComment {
  id               String   @id @default(cuid())
  postId           String
  userId           String
  parentCommentId  String?
  content          String   @db.Text
  createdAt        DateTime @default(now())

  post           CreatorPost         @relation(fields: [postId], references: [id], onDelete: Cascade)
  user           User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentComment  CreatorPostComment? @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies        CreatorPostComment[] @relation("CommentReplies")

  @@index([postId])
  @@index([userId])
  @@index([parentCommentId])
}

enum CreatorSubscriptionStatus {
  active
  cancelled
}

model CreatorSubscription {
  id           String                  @id @default(cuid())
  subscriberId String
  creatorId    String
  status       CreatorSubscriptionStatus @default(active)
  subscribedAt DateTime               @default(now())
  cancelledAt DateTime?

  subscriber User @relation("CreatorSubscriptionSubscriber", fields: [subscriberId], references: [id], onDelete: Cascade)
  creator    User @relation("CreatorSubscriptionCreator", fields: [creatorId], references: [id], onDelete: Cascade)

  @@unique([subscriberId, creatorId])
  @@index([subscriberId])
  @@index([creatorId])
}

// Paid subscriptions via Stripe (creator publishing MVP)
model CreatorStripeSubscription {
  id                    String   @id @default(cuid())
  creatorId             String
  subscriberEmail       String
  stripeSubscriptionId String   @unique
  status                String   @default("active")
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  creator User @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([creatorId])
  @@index([subscriberEmail])
}

  id          String   @id @default(cuid())
  userId      String   @unique
  displayName String?
  avatarUrl   String?
  bio         String?  @db.Text
  website     String?
  twitter     String?
  youtube     String?
  isCreator   Boolean  @default(false)
  creatorTagline String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Community {
  id          String             @id @default(cuid())
  name        String
  slug        String             @unique
  description String?            @db.Text
  imageUrl    String?
  ownerId     String
  visibility  CommunityVisibility @default(public)
  isPaid      Boolean            @default(false)
  defaultTierId String?
  articleApprovalRequired Boolean @default(false)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  owner  User     @relation("CommunityOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  spaces Space[]
  members Member[]
  posts  Post[]   @relation("CommunityPosts")
  articles Article[]
  events Event[]
  subscriptionTiers SubscriptionTier[]
}

model Space {
  id          String    @id @default(cuid())
  communityId String
  name        String
  slug        String
  description String?   @db.Text
  type        SpaceType @default(general)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  posts     Post[]

  @@unique([communityId, slug])
}

model Member {
  id          String     @id @default(cuid())
  userId      String
  communityId String
  role        MemberRole @default(member)
  joinedAt    DateTime   @default(now())

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@unique([userId, communityId])
}

model Post {
  id        String     @id @default(cuid())
  spaceId   String
  communityId String
  authorId  String
  title     String
  body      String     @db.Text
  type      PostType   @default(post)
  status    PostStatus @default(draft)
  embedding Unsupported("vector(1536)")?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  space     Space     @relation(fields: [spaceId], references: [id], onDelete: Cascade)
  community Community @relation("CommunityPosts", fields: [communityId], references: [id], onDelete: Cascade)
  author    User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments  Comment[]

  @@index([authorId])
  @@index([communityId])
  @@index([spaceId])
  @@index([status, createdAt])
}

model Comment {
  id        String   @id @default(cuid())
  postId    String
  authorId  String
  body      String   @db.Text
  parentId   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  post   Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  author User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent Comment? @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies Comment[] @relation("CommentReplies")

  @@index([postId])
  @@index([authorId])
  @@index([parentId])
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  targetId  String
  title     String?
  message   String?          @db.Text
  read      Boolean         @default(false)
  createdAt DateTime        @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Event {
  id           String    @id @default(cuid())
  communityId  String
  creatorId    String
  title        String
  description  String?   @db.Text
  startAt      DateTime
  endAt        DateTime
  location     String?
  type         EventType @default(online)
  imageUrl     String?
  maxAttendees Int?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  community Community  @relation(fields: [communityId], references: [id], onDelete: Cascade)
  rsvps    EventRsvp[]
}

model EventRsvp {
  id        String     @id @default(cuid())
  eventId   String
  userId    String
  status    RsvpStatus @default(going)
  createdAt DateTime   @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
}

model SubscriptionTier {
  id          String   @id @default(cuid())
  communityId String
  name        String
  price       Int
  interval    String
  benefits    String?  @db.Text
  stripePriceId String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  community     Community      @relation(fields: [communityId], references: [id], onDelete: Cascade)
  subscriptions Subscription[]
}

model Subscription {
  id                   String             @id @default(cuid())
  subscriberId         String
  communityId          String
  tierId               String
  status               SubscriptionStatus @default(active)
  stripeSubscriptionId String?
  currentPeriodEnd     DateTime?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  subscriber User             @relation(fields: [subscriberId], references: [id], onDelete: Cascade)
  tier       SubscriptionTier @relation(fields: [tierId], references: [id], onDelete: Cascade)

  @@index([subscriberId])
  @@index([communityId])
  @@index([status])
}

model Activity {
  id         String   @id @default(cuid())
  userId     String
  type       String
  targetType String
  targetId   String
  metadata   Json?
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ContactSubmission {
  id           String   @id @default(cuid())
  firstName    String
  lastName     String
  email        String
  company      String?
  role         String?
  inquiryType  String
  communitySize String?
  message      String   @db.Text
  read         Boolean  @default(false)
  createdAt    DateTime @default(now())

  @@index([createdAt])
  @@index([inquiryType])
}

// Email queue: database-backed message queue for reliable email delivery
model EmailJob {
  id             String   @id @default(cuid())
  emailType      String
  recipientEmail String
  recipientName  String?
  templateData   Json
  metadata       Json?
  status         EmailJobStatus @default(pending)
  attempts       Int      @default(0)
  maxAttempts    Int      @default(7)
  lastError      String?  @db.Text
  scheduledAt    DateTime @default(now())
  startedAt     DateTime?
  completedAt   DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([status, scheduledAt])
  @@index([emailType])
}

enum EmailJobStatus {
  pending
  processing
  completed
  failed
  dead
}

// Email feedback: bounces, complaints for list hygiene
model EmailFeedback {
  id             String   @id @default(cuid())
  email          String
  type           EmailFeedbackType
  espEventId     String?
  rawPayload     Json?
  processed      Boolean  @default(false)
  createdAt      DateTime @default(now())

  @@index([email])
  @@index([type])
  @@index([processed])
}

enum EmailFeedbackType {
  bounce
  complaint
  delivered
}

// Unsubscribe tracking for CAN-SPAM/GDPR compliance
model EmailUnsubscribe {
  id        String   @id @default(cuid())
  email     String   @unique
  reason    String?
  createdAt DateTime @default(now())

  @@index([email])
}

// Wikipedia-style knowledge articles with revision history
model Article {
  id          String     @id @default(cuid())
  slug        String     @unique
  title       String
  body        String     @db.Text
  summary     String?    @db.Text
  communityId String?
  authorId    String
  status      PostStatus @default(draft)
  embedding   Unsupported("vector(1536)")?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  community   Community?        @relation(fields: [communityId], references: [id], onDelete: SetNull)
  author      User              @relation(fields: [authorId], references: [id], onDelete: Cascade)
  revisions   ArticleRevision[]
  citations   ArticleCitation[]

  @@index([authorId])
  @@index([communityId])
  @@index([status])
  @@index([slug])
}

model ArticleRevision {
  id            String    @id @default(cuid())
  articleId     String
  body          String    @db.Text
  authorId      String
  changeSummary String?
  approvedAt   DateTime?
  approvedById  String?
  createdAt     DateTime  @default(now())

  article   Article   @relation(fields: [articleId], references: [id], onDelete: Cascade)
  author    User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  approver  User?      @relation("ArticleRevisionApprover", fields: [approvedById], references: [id], onDelete: SetNull)
  citations ArticleCitation[]

  @@index([articleId])
  @@index([authorId])
  @@index([createdAt])
}

model ArticleCitation {
  id         String   @id @default(cuid())
  articleId  String
  revisionId String?
  url        String   @db.Text
  title      String?
  quote      String?  @db.Text
  createdAt  DateTime @default(now())

  article  Article         @relation(fields: [articleId], references: [id], onDelete: Cascade)
  revision ArticleRevision? @relation(fields: [revisionId], references: [id], onDelete: SetNull)

  @@index([articleId])
  @@index([revisionId])
}

// Analytics: raw event storage for product analytics and dashboards
model AnalyticsEvent {
  id         String   @id @default(cuid())
  eventId    String   @unique
  eventName  String
  timestamp  DateTime
  userId     String?
  sessionId  String
  payload    Json
  createdAt  DateTime @default(now())

  @@index([eventName])
  @@index([userId])
  @@index([timestamp])
  @@index([eventName, timestamp])
}
